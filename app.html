<!doctype html>
<html lang="en">
<head>
	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width,initial-scale=1" />
	<title></title>
	<link href="https://fonts.googleapis.com/css2?family=Inter:wght@100..900&display=swap" rel="stylesheet">
	<style>
		:root{--bg:#0f1724;--card:#111827;--muted:#9ca3af;--accent:#60a5fa;--accent-dark:#4f92f8;--danger:#ef4444}
		*{box-sizing:border-box;font-family:Inter,ui-sans-serif,system-ui,Segoe UI,Roboto,"Helvetica Neue",Arial}
		body{background:linear-gradient(180deg,#071029 0%, #07121a 100%);color:#e6eef8;margin:0;padding:24px}
		.wrap{max-width:920px;margin:0 auto}
		header{display:flex;align-items:center;gap:16px;margin-bottom:18px; justify-content: space-between;}
		h1{font-size:20px;margin:0}
		p.lead{margin:0;color:var(--muted);font-size:14px}

		/* Live Time Display */
		.live-time {
			font-size: 24px;
			font-weight: 700;
			color: var(--accent);
			background: rgba(96, 165, 250, 0.1);
			padding: 8px 12px;
			border-radius: 8px;
			box-shadow: 0 0 10px rgba(96, 165, 250, 0.3);
		}

		/* Notification Banner Styling */
		#notificationBanner {
			display: none;
			position: fixed;
			top: 24px;
			left: 50%;
			transform: translateX(-50%);
			z-index: 10;
			padding: 12px 20px;
			background-color: #f59e0b; /* Amber */
			color: #1f2937;
			font-weight: 700;
			border-radius: 8px;
			box-shadow: 0 4px 16px rgba(0,0,0,0.4);
			font-size: 16px;
			animation: pulse 1.5s infinite;
		}
		@keyframes pulse {
			0%, 100% { opacity: 1; transform: translateX(-50%) scale(1); }
			50% { opacity: 0.9; transform: translateX(-50%) scale(1.02); }
		}

		.card{background:var(--card);padding:16px;border-radius:12px;box-shadow:0 6px 20px rgba(2,6,23,0.6);}
		.grid{display:grid;grid-template-columns:1fr 360px;gap:16px}
		textarea{
			width:100%;min-height:240px;padding:12px;border-radius:8px;
			border:1px solid rgba(255,255,255,0.1);background:rgba(255,255,255,0.02);
			color:inherit;font-size:13px;transition:border-color 0.2s, box-shadow 0.2s;
		}
		textarea:focus { outline: none; border-color: var(--accent); box-shadow: 0 0 0 3px rgba(96, 165, 250, 0.4); }
		label{display:block;font-size:12px;margin-bottom:8px;color:var(--muted)}
		.controls{display:flex;gap:8px;margin-top:12px}
		
		/* Buttons */
		button{
			background:var(--accent);border:0;padding:10px 14px;border-radius:10px;
			color:#06202b;font-weight:600;cursor:pointer;
			transition: background-color 0.2s, box-shadow 0.2s, transform 0.1s;
			white-space: nowrap;
		}
		button:hover{ background: var(--accent-dark); box-shadow: 0 4px 12px rgba(96, 165, 250, 0.4); }
		button:active{ transform: scale(0.98); }

		button.ghost{background:transparent;border:1px solid rgba(255,255,255,0.1);color:var(--muted); padding:8px 12px;}
		button.ghost:hover{ background: rgba(255,255,255,0.06); border-color: rgba(255,255,255,0.2); box-shadow: none; }
		button.ghost:active{ background: rgba(255,255,255,0.03); }

		.small{font-size:13px;}
		
		/* Output & Results */
		table{width:100%;border-collapse:collapse;margin-top:10px}
		th,td{padding:8px 6px;text-align:left;border-bottom:1px solid rgba(255,255,255,0.05);font-size:13px}
		th{color:var(--muted);font-weight:600;text-transform:uppercase;font-size:11px}
		td:nth-child(3){font-weight:600;}

		.result{margin-top:16px;padding:14px;border-radius:10px;background:linear-gradient(90deg, rgba(96,165,250,0.08), rgba(96,165,250,0.03));color:#dbeafe; border: 1px solid rgba(96,165,250,0.2);}
		.pred{font-size:24px;font-weight:700}
		.muted{color:var(--muted)}
		.inline{display:flex;gap:8px;align-items:center}
		.spark{height:48px;margin-top:10px}
		.stats-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px; margin-top: 10px;}
		.stat-box { background: rgba(0,0,0,0.2); padding: 8px; border-radius: 6px; font-size: 13px; }
		.stat-box .val { font-weight: 700; color: #fff; font-size: 14px; display: block; margin-top: 2px;}

		.error-box { padding: 10px; background: rgba(239, 68, 68, 0.1); border: 1px solid var(--danger); border-radius: 8px; color: var(--danger); font-size: 13px; margin-top: 12px;}

		footer{margin-top:24px;color:var(--muted);font-size:12px;text-align:center;}

		@media (max-width:880px){
			.grid{grid-template-columns:1fr;}
			.card{padding:12px;}
			.controls{flex-wrap: wrap;}
			.live-time { font-size: 20px; padding: 6px 10px; }
		}
	</style>
</head>
<body>
	<div class="wrap">
		<header>
			<div>
				<h1>Time Pattern Predictor</h1>
				<p class="lead">Compute gaps between times in **HH:MM:SS** format and predict the next entry using a dynamic alternating-gap model.</p>
			</div>
			<!-- LIVE TIME DISPLAY -->
			<div id="liveTime" class="live-time"></div>
		</header>

		<!-- Notification Banner -->
		<div id="notificationBanner" style="display:none;">PREDICTION ALERT: Next time approaching!</div>

		<div class="grid">
			<div class="card">
				<label for="timesInput">Enter Times (one per line, e.g., 10:23:36)</label>
				<textarea id="timesInput" placeholder="10:23:36&#10;10:24:56&#10;10:27:27&#10;10:29:07"></textarea>
				<div class="controls">
					<button id="calcBtn">Calculate & Predict</button>
					<button id="addNow" class="ghost small">Add Current Time</button>
					<button id="clearBtn" class="ghost small">Clear All</button>
					<button id="copyBtn" class="ghost small" style="display: none;">Copy Prediction</button>
				</div>

				<div id="output"></div>
			</div>

			<div>
				<div class="card">
					<label>Analysis & Gaps</label>
					<div id="gapsArea">Enter times and click "Calculate & Predict".</div>
					<div class="spark" id="sparkArea"></div>
					
					<div class="result" id="resultArea" style="display:none">
						<div class="inline"><div class="muted">Last recorded time:</div><div id="lastTime" style="margin-left:6px;font-weight:700"></div></div>
						
						<div style="margin-top:12px">
							<div class="muted" style="font-size:13px;">Predicted Next Time:</div>
							<div id="predTime" class="pred"></div>
						</div>
						
						<div style="margin-top:12px; font-size: 12px;">
							<div class="muted">Prediction Heuristic Breakdown:</div>
							<div class="stats-grid">
								<div class="stat-box">Median Gap:<span id="statMed" class="val"></span></div>
								<div class="stat-box">Last Gap:<span id="statLast" class="val"></span></div>
								<div class="stat-box">Average Low Gap:<span id="statLow" class="val"></span></div>
								<div class="stat-box">Average High Gap:<span id="statHigh" class="val"></span></div>
							</div>
							<div class="muted" style="margin-top:8px;" id="algoNote"></div>
						</div>
					</div>
				</div>

				<!-- Removed Prediction Logic Section -->
				
			</div>
		</div>

		<footer>This tool uses a simple statistical heuristic for forecasting time patterns. It is an estimate and not guaranteed to be accurate.</footer>
	</div>

	<script>
		// Global state to hold the last successful prediction time (in seconds of the day)
		let currentPredictedTimeSec = null;

		// --- Utility Functions ---
		function parseTimeToSeconds(t){
			if(!t) return null;
			t = t.trim();
			const parts = t.split(':').map(x=>x.trim());
			if(parts.length !== 3) return null;
			const h = parseInt(parts[0],10);
			const m = parseInt(parts[1],10);
			const s = parseInt(parts[2],10);
			if(Number.isNaN(h)||Number.isNaN(m)||Number.isNaN(s) || h < 0 || m < 0 || s < 0) return null;
			return h*3600 + m*60 + s;
		}

		function secondsToHMS(sec){
			sec = Math.round(sec);
			sec = ((sec % 86400) + 86400) % 86400; // wrap in day (0 to 86399)
			const h = Math.floor(sec/3600);
			const m = Math.floor((sec%3600)/60);
			const s = sec%60;
			return [h,m,s].map(x=>String(x).padStart(2,'0')).join(':');
		}

		function median(arr){
			if(!arr.length) return 0;
			const a = arr.slice().sort((x,y)=>x-y);
			const mid = Math.floor(a.length/2);
			return a.length%2 ? a[mid] : (a[mid-1]+a[mid])/2;
		}
		
		function toSecondsLabel(s) {
			return `${s}s`;
		}

		// --- Main Logic ---
		function computePrediction(times){
			const secs = times.map(parseTimeToSeconds).filter(x=>x!==null);
			if(secs.length < 2) return {error:'Please enter at least 2 valid times in HH:MM:SS format.'};
			
			// Compute gaps
			const gaps = [];
			for(let i=1;i<secs.length;i++){
				gaps.push(secs[i]-secs[i-1]);
			}
			
			// Statistical analysis
			const med = median(gaps);
			const lows = gaps.filter(g=>g<=med);
			const highs = gaps.filter(g=>g>med);
			
			const avgLow = lows.length? Math.round(lows.reduce((a,b)=>a+b,0)/lows.length): Math.round(med*0.9);
			const avgHigh = highs.length? Math.round(highs.reduce((a,b)=>a+b,0)/highs.length): Math.round(med*1.3);
			
			const lastGap = gaps[gaps.length-1];
			
			// Prediction logic: Alternating low/high
			const predictedGap = (lastGap <= med) ? avgHigh : avgLow;
			const lastTimeSec = secs[secs.length-1];
			
			// Calculate predicted time and ensure it wraps within the 24-hour cycle
			let predictedTimeSec = lastTimeSec + predictedGap;
			predictedTimeSec = ((predictedTimeSec % 86400) + 86400) % 86400;

			return {
				gaps, med, avgLow, avgHigh, lastGap, predictedGap, lastTimeSec, predictedTimeSec, secs
			};
		}

		// --- UI Wiring ---
		const timesInput = document.getElementById('timesInput');
		const calcBtn = document.getElementById('calcBtn');
		const output = document.getElementById('output');
		const gapsArea = document.getElementById('gapsArea');
		const resultArea = document.getElementById('resultArea');
		const lastTimeEl = document.getElementById('lastTime');
		const predTimeEl = document.getElementById('predTime');
		const algoNote = document.getElementById('algoNote');
		const sparkArea = document.getElementById('sparkArea');
		const addNow = document.getElementById('addNow');
		const clearBtn = document.getElementById('clearBtn');
		const copyBtn = document.getElementById('copyBtn');
		const notificationElement = document.getElementById('notificationBanner');
		const liveTimeEl = document.getElementById('liveTime'); // Reference for the new element
		
		const statMed = document.getElementById('statMed');
		const statLow = document.getElementById('statLow');
		const statHigh = document.getElementById('statHigh');
		const statLast = document.getElementById('statLast');


		function renderResult(obj, rawTimes){
			output.innerHTML = ''; // Clear previous error messages
			copyBtn.style.display = 'block';

			if(obj.error){
				output.innerHTML = `<div class="error-box">${obj.error}</div>`;
				gapsArea.innerHTML='No data to analyze.'; 
				resultArea.style.display='none'; 
				sparkArea.innerHTML = '';
				copyBtn.style.display = 'none';
				currentPredictedTimeSec = null; // Clear global prediction on error
				return; 
			}

			// Gaps table
			let html = '<table><thead><tr><th>#</th><th>Time</th><th>Gap</th></tr></thead><tbody>';
			for(let i=0;i<obj.secs.length;i++){
				const t = secondsToHMS(obj.secs[i]);
				const g = i===0? '-' : toSecondsLabel(obj.gaps[i-1]);
				html += `<tr><td>${i+1}</td><td>${t}</td><td>${g}</td></tr>`;
			}
			html += '</tbody></table>';
			gapsArea.innerHTML = html;

			// spark (simple svg bars)
			const maxGap = Math.max(...obj.gaps, 1);
			let svg = `<svg width="100%" height="48" viewBox="0 0 200 48" preserveAspectRatio="none">`;
			// Calculate bar width dynamically based on the number of gaps
			const numGaps = obj.gaps.length;
			const totalSpacing = numGaps > 1 ? (numGaps - 1) * 2 : 0; // 2 units spacing between bars
			const totalWidth = 200 - totalSpacing;
			const barW = Math.max(3, Math.floor(totalWidth / numGaps));
			
			obj.gaps.forEach((g,i)=>{
				const h = Math.round((g/maxGap)*36)+6; // minimum height of 6
				const x = i*(barW+2); // x position with spacing
				svg += `<rect x="${x}" y="${48-h}" width="${barW}" height="${h}" rx="1" fill="rgba(96,165,250,0.9)" />`;
			});
			svg += `</svg>`;
			sparkArea.innerHTML = svg;

			// result area
			lastTimeEl.textContent = secondsToHMS(obj.lastTimeSec);
			predTimeEl.textContent = secondsToHMS(obj.predictedTimeSec);
			
			// Detailed stats for stat boxes
			statMed.textContent = toSecondsLabel(Math.round(obj.med));
			statLow.textContent = toSecondsLabel(obj.avgLow);
			statHigh.textContent = toSecondsLabel(obj.avgHigh);
			statLast.textContent = toSecondsLabel(obj.lastGap);

			// Algorithm note
			const action = (obj.lastGap <= obj.med) ? 'low (â‰¤ median)' : 'high (> median)';
			const predictionSource = (obj.lastGap <= obj.med) ? toSecondsLabel(obj.avgHigh) : toSecondsLabel(obj.avgLow);
			const predictionType = (obj.lastGap <= obj.med) ? 'Avg High' : 'Avg Low';
			
			algoNote.innerHTML = `The last gap (${toSecondsLabel(obj.lastGap)}) was classified as **${action}**, so the next predicted gap is **${predictionSource}** (${predictionType}).`;
			
			// Store prediction time globally for the proximity check
			currentPredictedTimeSec = obj.predictedTimeSec;

			resultArea.style.display = 'block';
		}

		// --- Proximity Check Logic ---
		function checkProximity() {
			if (!currentPredictedTimeSec || !notificationElement) {
				if (notificationElement) notificationElement.style.display = 'none';
				return;
			}

			const now = new Date();
			const nowSecOfDay = now.getHours() * 3600 + now.getMinutes() * 60 + now.getSeconds();
			
			// Calculate the difference. Both times are in seconds of the day (0-86399).
			let diffSec = currentPredictedTimeSec - nowSecOfDay;

			// Handle wrap-around: If the difference is large and negative, it means the prediction wraps to the next day.
			if (diffSec < -43200) { 
				diffSec += 86400;
			}

			const threshold = 15; // 15 seconds threshold

			if (diffSec > 0 && diffSec <= threshold) {
				const timeToArrival = Math.round(diffSec);
				const predictedHMS = secondsToHMS(currentPredictedTimeSec);
				
				notificationElement.textContent = `PREDICTION ALERT: Next time (${predictedHMS}) in ${timeToArrival}s!`;
				notificationElement.style.display = 'block';
			} else {
				notificationElement.style.display = 'none';
			}
		}

		// --- Live Time Update Function ---
		function updateLiveTime() {
			const now = new Date();
			const hh = String(now.getHours()).padStart(2, '0');
			const mm = String(now.getMinutes()).padStart(2, '0');
			const ss = String(now.getSeconds()).padStart(2, '0');
			
			if (liveTimeEl) {
				liveTimeEl.textContent = `${hh}:${mm}:${ss}`;
			}
		}


		calcBtn.addEventListener('click', ()=>{
			const raw = timesInput.value.split('\n').map(x=>x.trim()).filter(x=>x);
			const res = computePrediction(raw);
			renderResult(res, raw);
		});

		addNow.addEventListener('click', ()=>{
			const now = new Date();
			const hh = String(now.getHours()).padStart(2,'0');
			const mm = String(now.getMinutes()).padStart(2,'0');
			const ss = String(now.getSeconds()).padStart(2,'0');
			const line = `${hh}:${mm}:${ss}`;
			const cur = timesInput.value.trim();
			// Only add if the current time isn't identical to the last line to prevent accidental duplicate clicks
			const lastLine = cur.split('\n').pop().trim();
			if (lastLine !== line) {
				timesInput.value = cur ? (cur + '\n' + line) : line;
				// Automatically re-calculate after adding a new time
				calcBtn.click();
			}
		});

		clearBtn.addEventListener('click', ()=>{
			timesInput.value = '';
			gapsArea.innerHTML = 'Enter times and click "Calculate & Predict".';
			output.innerHTML = '';
			resultArea.style.display = 'none';
			sparkArea.innerHTML = '';
			copyBtn.style.display = 'none';
			currentPredictedTimeSec = null;
		});

		copyBtn.addEventListener('click', ()=>{
			const pred = document.getElementById('predTime').textContent;
			if(!pred) return;
			// Use document.execCommand for better compatibility in environments where clipboard API might be restricted
			const tempInput = document.createElement('textarea');
			tempInput.value = pred;
			document.body.appendChild(tempInput);
			tempInput.select();
			document.execCommand('copy');
			document.body.removeChild(tempInput);

			// Provide feedback
			copyBtn.textContent = 'Copied!';
			setTimeout(()=>{
				copyBtn.textContent='Copy Prediction';
			},1000);
		});

		// Auto-calc on load with demo data and start the real-time check
		timesInput.value = `10:23:36\n10:24:56\n10:27:27\n10:29:07\n10:31:16\n10:32:55\n10:34:17\n10:36:44\n10:41:25`;
		setTimeout(()=>{
			calcBtn.click();
			
			// Start live time display and prediction check loop every 1 second
			updateLiveTime();
			setInterval(updateLiveTime, 1000);
			setInterval(checkProximity, 1000);
		},100);
	</script>
</body>
</html>